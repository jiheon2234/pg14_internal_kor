
스냅샷 격리 덕분에, 힙 튜플은 읽기를 위해 잠글 필요가 없다. 그러나 두 쓰기 트랜잭션이 동일한 행을 동시에 수정하는 것은 허용되지 않는다.
행은 이 경우에 잠기지만,  *heavyweight locks*는 이 경우에는 별로 좋은 선택이 아니다 : 이 락 각각은 서버의 공유 메모리를 차지하고(몇백바이트가 소모되며, 관련 자원 인프라까지 포함하면 더 많다), PostgreSQL 내부 매커니즘은 많은 수의 동시 *heavyweight locks*를 처리하도록 설계되지 않았다.

몇몇 데이터베이스는 락 에스컬레이션을 통해 이 문제를 해결한다 : 만약 행 잠금이 너무 많으면, 이를 더 세밀한 단일 잠금(예를 들어 페이지 수준이나 테이블 수준의 잠금)으로 대체한다. 이는 구현을 단순화하지만, 시스템의 처리량을 크게 단순화한다.

PostgreSQL에서, 특정 행이 잠겨 있는지의 정보는 해당 행의 현재 힙 튜플에만 저장된다.  행 수준의 락은 실제 잠금이라기보단 가상의 속성처럼 취급되며, 어떠한 방식으로던 RAM에 반영되지 않는다.

행은 일반적으로 업데이트되거나 삭제될 때 잠긴다. 두 경우 모두, 행의 현재 버전은 삭제마크가 표시된다. 이를 위해 사용되는 속성은 현재 트랜잭션의 ID로, *xmax* 필드에 저장되고, 이  ID (힌트비트와 결합해서)  는 행이 잠겼다는 것을 나타내기도 한다.
만약 트랜잭션이 행을 수정하고 싶지만 *xmax* 필드에 활성화된 트랜잭션 ID가 있다면, 그 트랜잭션이 완료되기를 기다려야 한다. 트랜잭션이 완료되면, 잠금이 해제되고, 대기 중이던 트랜잭션은 작업을 계속한다.

이 메커니즘은 추가 비용 없이 필요한 만큼 많은 행들을 잠글 수 있다.

이 솔루션의 단점은 다른 프로세스들이 queue를 형성한다는 것인데, RAM에는 이러한 잠금에 대한 정보가 없기 때문에 *heavyweight locks* 가 여전히 필요하다 : 
행을 해제하기 위해 대기 중인 프로세스는 현재 해당 행을 처리 중인 트랜잭션의 ID에 대한 잠금을 요청한다. 트랜잭션이 완료되면, 행은 다시 사용 가능해진다.
따라서 *heavyweight locks*의 수는 수정 중인 행의 개수가 아니라 동시 실행 중인  프로세스의 수에 비례하계 된다.


