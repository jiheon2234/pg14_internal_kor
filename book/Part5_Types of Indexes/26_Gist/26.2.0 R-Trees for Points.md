첫 예시는 평면 위의 점 (또는 도형)을 인덱싱하는 경우이다.
B-tree는 이 데이터 타입에 사용할 수 없는데, 점에 대해 정의된 비교 연산자가 없기 때문이다.
우리는 이 연산자를 직접 구현할 수도 있지만, 기하학적 도형은 전혀 다른 종류의 연산에 대한 인덱스 지원이 필요하다. 여기서는 두 가지 예를 다루겠다 : 특정 영역에 포함된 객체 검색과, 최근접 이웃 검색이다.

R-tree는 평면 위에 사각형을 들어서 모든 인덱스된 점들을 포함하도록 구성한다.
각 인덱스 항목은 경계 상자를 저장하며, 조건은 다음과 같이 정의할 수 있다 : *점이 이 상자 안에 위치한다.*

R-tree의 루트에는 여러 큰 사각형이 포함되어 있다(겹칠 수도 있음).
자식 노드는 부모 노드에 맞춰진 더 작은 사각형을 포함하며, 이들 사각형은 모든 하위 점들을 포함하도록 구성된다.

리프 노드는 인덱싱된 점들을 직접 포함해야 하지만, Gist는 모든 엔트리가 동일한 데이터 타입을 가져야 하므로 리프 엔트리도 사각형으로 표시된다 ; 그러나, 리프 엔트리의 사각형은 단순히 점으로 축소된다.

이 구조를 더 잘 시각화하기 위해, 공항 좌표로 구성된 R-tree의 세 레벨을 살펴보자.
이 예제에서는 데모 데이터베이스의 공항 예제를 5천개로 확장했다. [^1] 또한 *fillfactor* 값을 줄여서 트리 깊이를 증가시켰다.

```sql
=> CREATE TABLE airports_big AS
   SELECT * FROM airports_data;

=> COPY airports_big FROM '/home/student/internals/airports/extra_airports.copy';

=> CREATE INDEX airports_gist_idx ON airports_big
   USING gist(coordinates) WITH (fillfactor=10);
```

최상위 레벨에서는, 모든 점들이 여러개의(부분적으로 겹치는) 경계 상자에 포함된다 :

![](image/CleanShot%20-000098.png)

다음 레벨에서는, 큰 사가형이 더 작게 분할된다 :

![](image/CleanShot%20-000099.png)

마지막으로, 트리의 내부 레벨에서는 각 경계 상자가 하나의 페이지가 수용할 수 있는 최대한 많은 점들을 포함한다 : 

![](image/CleanShot%20-000100.png)

이 인덱스는 *points_ops*  연산자 클래스를 사용하며, 이는 점에 대해 사용할 수 있는 유일한 클래스이다.
사각형이나 기타 기하 도형도 동일한 방식으로 인덱싱할 수 있지만, 인덱스에는 객체 자체가 아닌 경계 상자가 저장된다.






[^1]:[여기서 다운받을 수 있음](https://edu.postgrespro.ru/internals-14/extra_airports.copy)