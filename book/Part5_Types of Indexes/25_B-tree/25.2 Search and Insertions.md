
## Search by Equality

"인덱싱된 열=표현식" 조건으로 트리에서 값을 검색하는 방법을 알아보자. [^1]
우리는 KJA 공항을 찾을 것이다.

검색은 루트 노드에서 시작하며, 접근 메서드는 내려갈 자식 노드를 결정해야 한다.
이때,  $K_i$ <= expression < $K_{i+1}$을 만족하는 $K_i$키를 선택한다.

루트 노드는 *AER*,*OVE* 키를 가지고 있다. AER  ≤ KJA  < OVB가 성립하므로, AER 키가 있는 요소가 참조하는 자식 노드로 내려가야 한다.

![](_static/CleanShot%20-000092.png)

이 절차는 필요한 튜플 ID를 포함하는 리프 노드에 도달할 때까지 재귀적으로 반복된다. 이 경우, 자식 노드가 `DME  ≤ KJA < KZN`를 만족하므로, DME 키가 있는 요소가 참조하는 리프 노드로 내려가야 한다.

알아차렸듯이, 트리 내부 노드에서 가장 왼쪽의 키들은 불필요하다 : 루트의 자식 노드를 선택하기 위해서, KJA < OVB만 만족하면 충분하다. B-tree에서는 이러한 키드를 저장하지 않으므로, 이후 그림에서는 해당 요소들을 비워 두겠다.

리프 노드에서 필요한 요소는 이진 검색을 통해 빠르게 찾을 수 있다. 

그러나, 검색 절차는 보이는것만큼 단순하지 않다. 인덱스의 데이터 정렬 순서가 오름차순일수도 있고, 내림차순일 수도 있다. 심지어 고유 인덱스에서도 여러 개의 일치하는 값이 있을 수 있으며, 이들 모두를 반환해야 한다. 게다가, 중복이 너무 많아서 하나의 노드에 모두 담을 수 없을 경우, 인접한 리프 노드도 처리해야 한다.

> 인덱스에 고유하지 않은 값들이 포함될 수 있으므로, 정렬 순서를 오름차순이 아닌 비내림차순이라고 부르는 것이 더 정확할 것이다. 하지만 여기서는 더 간단한 용어를 사용하겠다.
> 또한, 튜플 ID가 인덱스 키의 일부이므로, 실제 값이 동일하더라도 인덱스 항목을 고유한 것으로 간주할 수 있다.

게다가, 검색이 진행되는 동안 다른 프로세스가 데이터를 수정할 수 있으며, 페이지가 2개로 분할되거나 트리 구조가 변경될 수 있다. 
모든 알고리즘은 이러한 동시 작업 간의 경합을 최소화화고 불필요한 잠금을 피하도록 설계되어 있다. 여기서는 이러한 기술적 세부 사항에 대해서는 다루지 않겠다.

## Search by Inequality
만약 검색이 "인덱싱된 열 ≤ 표현식" (또는 “인덱싱된 열 ≥ 표현식”)으로 수행되는 경우, 먼저 동등 조건을 만족하는 값을 인덱스에서 찾고, 이후 트리의 끝에 도달할 때까지 리프 노드를 필요한 방향으로 순회해야 한다.

이 다이어그램은 공항코드가 DME (Domodedovo) 이하인 공항 코드를 검색하는 과정을 보여준다.
![](_static/CleanShot%20-000093.png)

`<,>` 연산자를 사용하는 경우, 절차는 동일하지만, 처음 발견된 값을 제외해야 한다.

## Search by Range
“expression1 ≤ 인덱스 열 ≤ expression2” 범위로 검색할 때, 우리는 먼저 expression1을 찾아야 하고, 이후 리프 노드를 오른쪽 방향으로 순회하여 expression2에 도달할 때까지 진행해야 한다.
이 다이어그램은 공항 코드가 LED 에서 ROV 사이인 항목을 검색하는 과정을 보여준다.

![](_static/CleanShot%20-000094.png)


## Insertions
새 요소의 삽입 순서는 키의 순서에 의해 명확히 정의된다. 예를 들어, RTW를 테이블에 삽입하면, 새 요소는 마지막에서 두 번째 리프 노드에서 ROV와 SGC 사이에 위치하게 된다.

근데, 리프 노드에 충분한 공간이 없다면? 예를 들어(노드는 최대 3개만 수용할 수 있다고 가정) 우리가 TJM 공항 코드를 삽입하면, 마지막 리프 노드는 꽉 찬다. 이 경우에, 노드는 두개로 분할되어 이전에 있던 요소들은 새 노드로 이동하고, 부모 노드에 새로운 자식 노드를 가리키는 포인터가 초과된다.
당연히, 부모 노드도 초과될수 있다. 그러면 두 노드로 분할되고, 같은 방식이 계속된다. 루트까지 분할되게 되면, 분할된 노드 위에 새로운 노드가 생성되어 트리의 루트가 되고, 깊이가 한 단계 증가하게 된다.

이 예시에서 TJM 공항의 삽입은 두번의 노드 분할을 초래한다; 결과 노드는 다이어그램에서 진하게 표시되었다. 어떤 노드던 분할될 수 있도록 양방향 리스트는 최하위 레벨뿐만 아니라 모든 레벨에서 노드들을 연결한다.

![](_static/CleanShot%20-000095.png)

설명된 삽입과 분할 전차는 트리가 균형을 유지하도록 보장한다. 또한, 하나의 노드가 수용할 수 있는 노드의 수가 상당히 많기 때문에, 트리의 깊이는 거의 증가하지 않는다.

문제는, 한번 분할된 노드들은 다시 합쳐질 수 없다는 것이다. vacuuming 후 요소가 거의 없는 경우에도 마찬가지이다.
이 제한은 B-tree 데이터 구조 자체의 문제라기보다는 PostgreSQL의 구현 방식에 기인한다. 따라서 삽입 시 노드가 가득 찬 경우, 접근 방식은 추가 분할을 피하기 위해 불필요한 데이터를 정리하여 일부 공간을 확보하려고 시도한다.




[^1]:[backend/access/nbtree/nbtsearch.c, _bt_search function](https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=src/backend/access/nbtree/nbtsearch.c;hb=REL_14_STABLE)