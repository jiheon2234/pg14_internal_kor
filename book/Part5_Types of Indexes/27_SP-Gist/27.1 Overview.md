Sp-Gist라는 이름에서 SP는 공간 분할(Space Partitioning)을 의미한다. 여기서 공간은 검색이 수행되는 임의의 값 집합을 나타내며, 반드시 일반적인 의미의 공간(예 : 2차원 평면)을 의미하는 것은 아니다.
Gist 부분은 Gist와 SP-Gist 방식 간의 특정 유사성을 암시한다 : 둘 다 다양한 데이터 타입을 인덱싱하기 위한 일반화된 검색 트리이다

SP-Gist 방식의 아이디어는[^1] 검색 공간을 여러 겹치지 않는 영역으로 분할하는 데 있다. 이러한 분할 방식은  R-tree와 Gist 트리와 달리 비균형 트리를 생성하며(B-tree, Gist트리와 다르다) quad트리, K-D 트리, radix 트리와 같은 잘 알려진 구조를 구현하는데 사용될 수 있다.

비균형 트리는 전형적으로 가지의 수가 적고, 그에 따라 깊이가 깊어진다.
예를 들어, 쿼드트리 노드는 최대 4개의 자식 노드를 가질 수 있으며, K-D트리 노드는 2개만 가능하다.
트리가 메모리에 있을 때는 문제가 없지만, 디스크에 저장되면, I/O를 최소화하기 위해 트리 노드들은 가능한 한 빽빽하게 페이지에 패킹되어야 하며, 이는 간단하지 않다.
B-tree와 Gist 인덱스들은 각 트리 노드가 전체 페이지를 차지하기 때문에 이러한 문제를 고려할 필요가 없다.

SP-Gist 트리의 내부 노드에는 해당 자식 노드에 대해 참이 되는 조건을 만족하는 값이 포함된다. 이러한 값들은 *prefix*라고 불리며, Gist 인덱스의 *predicate*와 같은 역활이다.
SP-Gist 자식 노드로 가는 포인터에는 라벨이 있을 수 있다.

리프 노드 요소에는 인덱싱된 값(또는 그 일부)와 해당 튜플 TID가 포함된다.

Gist와 마찬가지로, SP-Gist 접근 메서드는 동시 접근, 락, 로깅과 같은 저수준의 세부 사항들을 처리하는 주요 알고리즘만을 구현한다.
새로운 데이터 타입과 공간 분할 알고리즘은 연산자 클래스 인터페이스를 통해 추가할 수 있다.
연산자 클래스는 대부분의 로직을 제공하며, 인덱싱 기능의 여러 측면을 정의한다.

SP-Gist에서, 검색은 루트 노드에서 dfs로 진행된다. [^2] 
Gist 처럼 탐색할 가치가 있는 노드는 일관성 함수로 선택된다. 트리의 내부 노드에 대해, 이 함수는 검색 조건과 모순되지 않는 자식 노드들의 집합을 반환한다.
일관성 함수는 이러한 노드로 직접 내려가지 않고, 관련된 라벨과 prefix만 평가한다. 리프 노드의 경우, 해당 노드의 값이 검색 조건과 일치하는지 판단한다.

비균형 트리에서, 검색 시간은 분기의 깊이에 따라 달라진다.

Sp-Gist 인덱스에 값을 삽입할 때 두 가지 지원 함수가 참여한다.
트리가 루트 노드부터 탐색할때, *choose* 함수는 다음 중 하나를 결정한다 : 기존 자식 노드에 값을 삽입하거나, 새로운 자식 노드를 생성하거나, 현재 노드를 분할한다(만약 값이 현재 노드의 prefix와 일치하지 않으면).
만약 선택된 리프 페이지가 충분한 공간이 없으면, *picksplit* 함수가 어떤 노드들을 새로운 페이지로 옮길지 결정한다.

이제 이러한 알고리즘을 설명하기 위해 몇 가지 예를 제공하겠다.








[^1]:https://www.postgresql.org/docs/14/spgist.html
[backend/access/spgist/README](https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=src/backend/access/spgist/README;hb=REL_14_STABLE)
[^2]:[backend/access/spgist/spgscan.c, spgWalk function](https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=src/backend/access/spgist/spgscan.c;hb=REL_14_STABLE)