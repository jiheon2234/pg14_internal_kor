강력하긴 하지만, GIN 인덱스는 여전히 전체 텍스트 검색의 모든 문제를 해결하지 못한다.
*tsvector* 타입은 어휘의 위치를 나타내지만, 이 정보는 인덱스에 포함되지 않기 때문에 GIN은 어휘의 근접성을 고려한 *phase search*를 가속화하는데 사용할 수 없다.
게다가, 검색 엔진은 글자를 관련성 순서로 반환하는데(이 "관련성"의 의미는 다양할 수 있지만), GIN인덱스는 정렬을 지원하지 않기 때문에, 여기서는 각 결과 행에 대해서 함수를 계산하는 방법밖에 없다. (물론, 이는 매우 느림)

이러한 단점들은 *RUM* 접근 방식에 의해 보완되었다 (이름을 보면, 개발자들이 GIN에 진정한 의미에 대해 얼마나 진지한지 의문스럽다 ㅋ).
이 접근 방식은 확장으로 제공된다 ; PGDG 저장소[^1] 에서 다운로드하거나, 소스 코드를 직접 구할 수 있다.[^2]

RUM은 GIN을 기반으로 하지만, 두 주요 차이점이 있다.
첫째, 럼은 지연된 업데이트를 지원하지 않으므로, 비트맵 스캔뿐만 아니라 정규 인덱스 스캔을 지원하며, 정렬 연산자도 구현한다.
둘째, RUM 인덱스 키는 추가 정보를 확장할 수 있다. 이 기능은 어느정도 `INCLUDE` 열과 유사하지만, 여기서는 추가 정보가 특정 키에 연결된다.
전체 택스트 검색의 예시에서, RUM 연산자 클래스는 어휘 발생을 문서 내 위치에 매핑하여 *phrase* 검색과 결과 랭킹을 가속화한다.

이 접근 방식의 단점은 느린 업데이트 속도와 큰 인덱스 크기이다. 또한, RUM 접근 방식은 확장으로 제공되기 때문에, 내장된 로깅보다 느리고 더 많은 양의 WAL을 생성하는 일반적인 WAL 메커니즘에 의존한다. [^3]


[^1]:https://www.postgresql.org/download/
[^2]:[github.com/postgrespro/rum](https://github.com/postgrespro/rum)
[^3]:https://www.postgresql.org/docs/14/generic-wal.html