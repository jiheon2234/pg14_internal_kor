

저자들에 따르면, GIN은  술이 아니라 강력하고 용기있는 정신을 의미한다. [^1]
공식적인 해석도 있는데 : 이는 일반화된 역색인 (Generalized Inverted Index)를 의미한다.

GIN 접근 방식은 개별 요소들로 구성된 비원자 값들을 표현하는 데이터 타입을 위해 설계되었다(예를 들어, 전체 텍스트 검색에서 문서는 여러 어휘로 구성된다). 
Gist가 값 전체를 인덱싱하는 것과  달리, GIN은 각 요소를 개별적으로 인덱싱한다.
즉, 각 요소가 포함된 모든 값을 요소에 매핑하여 저장한다.

이 방법은 책의 색인과 비교할 수 있다. 책의 색인은 중요한 용어들을 포함하고, 이 용어들이 언급된 모든 페이지를 나열한다.
편리하게 사용하려면 색인은 알파벳순으로 정렬되어야 하며, 그렇지 않으면 빠르게 찾기 어렵다.
이와 유사하게, GIN은 복합 값의 모든 요소가 정렬될 수 있다는 점에 의존한다; 이 주요 데이터 구조는 B-tree 이다.

요소들의 GIN 트리 구현은 일반적인 B-tree보다 덜 복잡하다 : GIN 트리는 적은 수의 요소 집합이 여러 번 반복되는 경우를 처리하도록 설계되었기 때문이다.

이 가장은 두 중요한 결론을 이끌어낸다 :
- 요소는 인덱스에 한 번만 적용된다.
각 요소는 *posting list*라고 불리는 TID 리스트와 매핑된다. 이 리스트가 짧은 경우에는 요소와 함께 저장되며, 긴 리스트는 별도의 *posting tree*로 이동한다. 포스팅 트리는 실제로 B-tree 이다. 요소 트리와 마찬가지로, 포스팅 리스트도 정렬되는데, 이는 사용자 관점에서 큰 차이는 없지만 데이터 접근 속도를 높이고 인덱스 크기를 줄이는 데 도움이 된다.

- 트리에서 요소를 제거할 필요가 없다.
만약 특정 요소에 대한 TID 리스트가 비어 있어도, 동일 요소가 다른 값의 일부로 나타날 가능성이 높기 때문에 굳이 요소를 트리에서 제거할 필요가 없다.

따라서, 인덱스는 요소들로 구성된 트리이며, 그 리프 엔트리는 평탄화된 리스트나 TID 트리에 연결된다.

GIN 접근 방식은 Gist, SP-Gist 접근 방법과 마찬가지로 다양한 데이터 타입을 인덱싱할 수 있으며, 이를 위해 간소화된 연산자 클래스 인터페이스를 제공한다.
이러한 클래스들의 연산자는 일반적으로 인덱싱된 복합 값이 특정 요소 집합과 일치하는지 확인한다( `@@` 연산자가 문서가 특정 전체 텍스트 검색 쿼리를 만족하는지 확인하는 것처럼).

특정 데이터 타입을 인덱싱하려면, GIN 접근 방식이 복합 값을 개별 요소로 분할하고, 이들을 정렬하며, 검색된 값이 쿼리를 만족하는지 확인할 수 있어야 한다. 이러한 작업은 연산자 클래스의 지원 함수에 의해 구현된다.





[^1]:https://www.postgresql.org/docs/14/gin.html
[backend/access/gin/README](https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=src/backend/access/gin/README;hb=REL_14_STABLE)