관계형 데이터베이스의 주요 기능은, 데이터의 일관성을 보장하는 능력 (*correctness*)임.

데이터베이스 레벨에서 `not null`, `unique` 같은 무결성 제약 조건을 생성할 수 있다는 것은 잘 알려져 있음.
데이터베이스 시스템은 이런 조건이 절대 깨지지 않음을 보장하므로, 데이터 무결성은 절대 유지됨.

만약, 필요한 모든 필요한 제약 조건아 데이터베이스 레벨에서 정의된다면, 일관성은 보장됨.
그라너 어떤 조건들은 너무 복잡함, (예를 들어, 여러 테이블을 동시에 참조함)
그리고 제약조건을 데이터베이스에서 정의할 수 있어도, 어떠한 이유로 정의하지 않았다면, 그건 이 제약 조건을 위반할 수 있다는 걸 뜻하지 않음.

그러므로, 데이터 일관성은 무결성보다 더 엄격하지만, 데이터베이스 시스템은 "일관성"이 실제로 뭔 뜻인지 알지 못함.
만일 어플리케이션이 무결성을 깨뜨리지 않고 일관성을 깨뜨린다면, 데이터베이스 시스템이 이를 찾아낼 수 없음.
따라서, 데이터 일관성의 기준은 애플리케이션에 결정해야 하며, 우리는 애플리케이션이 잘 만들어졌고 에러가 절대 없을 거라고 믿어야 함.

하지만, 애플리케이션이 항상 올바른 연산 순서만을 실행한다면, 데이터베이스 시스템은 무슨 역활을 하는가?

우선, 올바른 연산 순서가 일시적으로 데이터 일관성은 깨뜨릴 수 있으며, -이상하게 들리겠지만- 이는 완전히 정상적임.

진부하지만 명확한 예시는 한 계좌에서 다른 계좌로의 이체임.
일관성 규칙은 다음과 같이 표현되는데 : 
*자금 이체는 연관된 계좌의 총 잔액을 절대로 변경해선 안됨*
이 규칙을 무결성 제약으로 데이터베이스에 정의하는 것은 꽤 어렵지만(불가능하진 않음), 이 규칙이 애플리케이션 레벨에서 정의되어 데이터베이스 시스템에는 불투명한 상태로 남아 있다고 가정하자.

이체는 두 작업으로 구성됨:
처음에 한 계좌에서 돈이 빠져나가고, 두 번째는 이 돈을 다른 계좌에 추가함.
첫 작업은 데이터 일관성을 깨뜨리고, 두 번째 작업은 이를 복구한다.

첫 번째 작업이 성공했지만, 두 번째 작업이 실패(특정 이유로)하면, 데이터 일관성이 깨짐.
이러한 상황은 용납할 수 없지만, 애플리케이션 수준에서 이를 감지하고 해결하긴 어려움.
다행히도, 이게 필요하지 않음- 이 문제는  두 작업이 하나의 불가분으로 묶인다는것, 즉 **트랜잭션**을 구성한다는 것을 데이터베이스 시스템이 알게되면 해결할 수 있음.

그러나 여기에는 더 미묘한 측면이 있음. 각각의 트랜잭션이 스스로는 완벽하게 동작해도, 병렬로 실행된다면 잘못 작동될 수도 있음.
왜냐면 다른 서로 다른 트랜잭션의 작업들이 가끔 섞여서임.
만일 데이터베이스 시스템이 먼저 하나의 트랜잭션을 완료하고 다음으로 이동한다면 이런 문제가 없겠지만, 이런 순차적 실행의 성능은 엄청 낮을것임.

> 트랜잭션의 *진정한* 동시 실행은 멀티코어나 디스크 배열같은 하드웨어가 있는 시스템에서만 가능함.
> 그러나 동일한 논리는 시분할 모드로 동작하는 서버에도 적용됨.
> 일반화의 목적으로, 이 두 상황 모두 *동시 실행(concurrent execution)* 이라고 부름

올바른 트랜잭션이 함께 실행될때 잘못 작동하면, *동시성 이상 현상*(concurency-anomalies), 동시성 현상(phenomena)* 이 발생함.

여기 간단한 예시가 있음. 데이터베이스에서 일관된 데이터를 얻기 위해선, 어플리케이션은 최소한 다른 트랜잭션에서 커밋되지 않은 데이터를 볼 수 있어선 안됨.
아니면 (일부 트랜잭션이 롤백되는 경우), 존재하지 않는 데이터를 보게 될 것임.
이러한 이상현상을 *dirty read* 라고 부름.
훨씬 복잡한다른 이상현상들도 많이 있음.\

트랜잭션을 동실해 실행할 때, 데이터베이스는 그 실행 결과가 가능한 순차적 실행 결과 중 하나와 동일하도록 보장해야됨.
다른 말로, 트랜잭션을 *격리*시켜 이상현상의 발생을 막아야됨.

요약하자면, 트랜잭션은 데이터베이스를 하나의 올바른 상태에서, 다른 올바른 상태로 바꾸는 일련의 작업임(일관성),  이 작업은 전부 실행되어야 하고(원자성)다른 트랜잭션에 위해 영향을 받지 않아야 함(고립성).
이 정의는 **ACID** 약어의 첫 3글자에 함축된  것임.
이것들은 매우 밀접하게 연관되어 있어서 같이 생각해야 함.
사실, 그중 하나라도 분리하는것은 거의 불가능: 충돌 이후에, 시스템에는 커밋되지 않은 트랜잭션에 의한 변경이 남아 있을 수 있고, 너는 이걸 해결해서 데이터 일관성을 복구해야됨.

따라서, 데이터베이스 시스템은 트랜잭션 경계를 고려하여 어플리케이션이 일관된 데이터를 유지하는걸 도움, 심지어 데이터베이스 시스템이 일관성에 대해 몰라도.

불행히도, 완전한 격리성을 고려하는 것은 시스템 성능에 악영향을 끼침.
대부분의 실제 시스템에서는  일부 이상 현상만을 방지하는 약한 격리 수준을 사용함.
그건 데이터를 유지하는 작업의 일부가 애플리케이션에 있다는 것을 뜻함.
그래서, 시스템에서 어떤 격리 수준이 사용되는지, 이 수준에서 무엇이 보장되고 보장되지 않는지, 이러한 조건에서 코드가 잘 동작하는지 아는 것은 매우 중요함.









