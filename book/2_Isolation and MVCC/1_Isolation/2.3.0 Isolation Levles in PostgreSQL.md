시간이 지나면서 ,트랜잭션 관리를 위한 lock 기반 프로토콜은 스냅샷 격리*Snapshot Isolation(SI)* 프로토콜로 대체됨.
이 접근 방식의 아이디어는 각 트랜잭션이 특정 시점에 존재했던 데이터의 일관된 스냅샷에 접근한다는것임.
이 스냅샷에는 스냅샷이 찍히기 전에 커밋된 모든 변경 사항이 포함됨.

스냅샷 격리는 필요한 잠금의 수를 최소화함.
사실, 행은 동시 업데이트 시도에 의해서만 잠김.
그 외에, 작업은 동시에 실행될 수 있음 :  쓰기는 읽기를 잠그지 않고, 읽기는 아무것도 잠그지 않음.

PostgreSQL은 다중 스냅샷 격리 프로토콜을 사용함.
Multiversion Concurrency Control(MVCC) 는 데이터베이스 시스템이 언제든지 동일한 행의 여러 버전을 포함할 수 있음을 나타냄.
그래서 Postgresql은 오래된(트랜잭션이 시작된 시점 이전의) 데이터를 읽으려는 트랜잭션을 중단시키는 대신, 적절한 버전을 스냅샷에 포함할 수 있음.

스냅샷들을 기반으로 하는,  Postgresql 격리성은 표준에서 명시한 것과 다름-심지어 더 엄격함.
Dirty reads는 설계상 금지됨.
기술적으로, 너는 Read Uncommitted 레벨을 지정할 수 있지만, Read Committed와 똑같이 동작하기 때문에 더이상 이 레벨에 대해 언급하지 않을 거임.

Repeatable Reads는 반복되지-않은 읽기와 팬텀 리드를 허용하지 않음(비록 완전한 격리성을 보장하지는 않지만). 그러나 Read Committed 레벨에서는 변경 사항이 손실될 위험이 있음.

||lost update|dirty read|non-repeatable read|phantom read| other anomalies|
|--|--|--|--|--|--|
|Read Committed|yes|-|yes|yes|yes|
|Repeatable Read|-|-|-|-|yes|
|Serializable Read|-|-|-|-|-|


격리성의 내부 메커니즘을 보기 전에, 사용자 관점에서 이 3가지 격리 레벨을 논의하자.
우리는 account 테이블을 생성할 것임;  Alice 와 Bob은 각각 $1000를 가지고 있으며, Bob은 두 계좌를 가지고 있음:

```sql
=> CREATE TABLE accounts(
	id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
	client text,
	amount numeric
);
=> INSERT INTO accounts VALUES
(1, 'alice', 1000.00), (2, 'bob', 100.00), (3, 'bob', 900.00);
```
