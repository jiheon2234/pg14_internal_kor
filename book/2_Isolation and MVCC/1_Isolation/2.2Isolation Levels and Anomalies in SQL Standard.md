SQL 표준은 4가지 격리 레벨을 지정함[^1] 
이 레벨들은 트랜잭션 동시 실행 중 발생할 수 있거나 발생하지 않을 수 있는 이상 현상의 목록으로 정의됨.
따라서 격리 수준에 대해 얘기할 때, 이상 현상부터 시작해야 함.

우리는 이 표준이 이론적 구성이라는 걸 유의해야 함: 이는 실제 상황에 영향을 미치지만, 실제 상황은 여러 면에서 표준과 다름.
그래서 여기있는 예시들은 가상적 예시임.
은행 계좌의 트랜잭션을 다룬 예시들은 상당히 자명하지만, 실제 은행 업무와는 아무와 관련이 없음.

흥미롭게도, 실제 데이터베이스 이론도 표준과 다름: 이는 표준이 채택된 이후 개발되었으며, 실제 구현은 한참 전에 됨.

## Lost Update
*lost update* 이상현상은 두 트랜잭션이 한 테이블의 동일한 행을 읽고, 하나가 그 행을 업데이트한 후 다른 트랜잭션이 첫 트랜잭션의 변경사항을 고려하지 않고 같은 행을 업데이트할 때 발생함.

두 개의 트랜잭션이 동일한 계좌의 잔액을 $100씩 증가시킨다고 하자.
첫 트랜잭션은 현재 잔액($1,000)을 읽고, 다른 트랜잭션이 같은 값을 읽음.
첫 트랜잭션이 값을 증가시킨다($1,100으로) 그리고 데이터베이스에 이 새 값을 씀.
두번째 트랜잭션도 동일한 작업을 수행함 : 잔액을 $1,100으로 업데이트하고 값을 씀.
결과적으로, 고객은 $100을 잃어버림.

*lost update*는 표준적으로 모든 격리 수준에서 금지됨.

## Dirty Reads and Read Uncommitted
*dirty read* 이상 현은 트랜잭션이 다른 트랜잭션에 의해 커밋되지 않은 변경사항을 읽을 수 있을때 발생함.

예를들어 첫 번째 트랜잭션이 $100을 빈 계좌에 이체하지만, 커밋하지 않음.
다른 트랜잭션은 이 계좌의 잔액을 읽고(업데이트됬지만 아직 커밋되지 않은) 고객이 출금하도록 허용함-첫 번째 트랜잭션이 중단되어 변경사항이 롤백되어 계좌가 비어 있어도

표준에선 *Read Uncommited* 레벨에서 dirty read를 허용함.

## Non-Repeatable Reads and Read Committed
*non-repeatable read*는 한 트랜잭션이 동일한 행을 두번 읽는 동안, 다른 트랜잭션이 그 행을 업데이트(또는 삭제)하고 그 변경사항을 커밋할 때 발생함.
결과적으로, 첫 트랜잭션은 서로 다른  결과를 얻음.

예를 들어, 은행 계좌에서 잔액이 음수가 되면 안 된다는 일관성 규칙이 있다고 가정함.
첫 트랜잭션은 잔액을 $100 감소시키려고 함.
현재 값을 확인했을때,  $1000가 있고, 연산이 가능하다고 결정.
같은 시간에, 다른 트랜잭션이 모든 돈을 인출하고 커밋함.
이 시점에서 첫 트랜잭션이 잔액을 다시 확인한다면, $0을 얻음 (그러나 이미 결정을 내렸기 때문에, 초과해서 인출하게 됨).

표준에선 *Read Uncommited* 및 *Read committed* 수준에서 non-repeatable을 허용.

## Phantom Reads and Repeatable Read
*phantom read* 이상 현상은, 동일한 트랜잭션이 특정 조건을 만족하는 행들을 반환하는  두 동일한 쿼리를 실행하는 사이에, 다른 트랜잭션이 조건을 만족하는 행을 추가하고 변경사항을 커밋할 때 발생함.
결과적으로, 첫 트랜잭션은, 서로 다른 결과 집합을 얻게 됨.

예를 들어, 고객에 3개 이상의 계좌를 만들 수 없는 일관성 규칙이 있음.
첫 트랜잭션이 새 계좌를 만들려고 하면서, 얼마나 많은 계좌가 있는지 확인하고(2개라고 가정), 작업이 가능하다고 판단함.
바로 그 순간, 두번째 트랜잭션이 똑같이 새로운 계좌를 만들고 커밋함.
만일 첫 트랜잭션이 계좌의 수를 다시 확인한다면, 3개가 될 것임(그러나 이미 계좌를 만들어서, 고객은 4개의 계좌를 가질것임).

표준에선 *Read Uncommited*, *Read Committed*, *Repeatable Read*에서 phantom read를 허용함.

## No Anomalies and Serializable

표준엔 *Serializable* 레벨도 있는데, 어떠한 이상현상도 허락하지 않음.
그러나 이건 lost updates, dirty, non-repeatable, phantom reads를 금지하는 것과는 다름.
실제로 표준에서 정의한 것 보다 훨씬 많은 이상현상이 존재하며, 아직 발견되지 않은 것들도 많음.

*Serializable* 레벨은 어떠한 이상현상도 방지해야 함.
이건 애플리케이션 개발자들이 격리성에 대해 신경쓸 필요가 없다는 것임.
트랜잭션이 단독으로 실행될때 올바른 순서를 따르면, 동시 실행은 데이터 일관성을 보장함.

이 아이디를 설명하기 위해,  잘 알려진 표준 테이블을 사용할 것임; 마지막 열은 명확하게 하기 위해 추가됨.


||lost update|dirty read|non-repeatable read|phantom read| other anomalies|
|--|--|--|--|--|--|
|Read Uncommitted|-|yes|yes|yes|yes|
|Read Committed|-|-|yes|yes|yes|
|Repeatable Read|-|-|-|yes|yes|
|Serializable Read|-|-|-|-|-|


## Why These Anomalies?

모든 가능한 이상 현상 중에서, 왜 표준은 일부만 언급하고, 하필 이것들임?

아무도 확실히 알지 못하는 것 같음.
그 당시에는 이론이 실제보다 훨씬 뒤쳐졌기 때문에 다른 이상 현상들이 당시에 첫 버전이 채택될 때 고려되지 않았을 수도 있음.

게다가, 격리성은 locks를 기반으로 해야 한다고 가정되었음.
널리 사용되는 *two-page locking protocol(2PL)* 은 트랜잭션이 실행되는 도중에 영향을 받는 행을 잠그고, 완료되면 그 잠금을 헤제하도록 요구함.
단순한 관점에서, 트랜잭션이 많은 lock을 획득할수록, 다른 트랜잭션으로부터 잘 격리됨.
그 결과로 시스템 성능은 더욱 나빠지는데, 트랜잭션이 동시에 실행되지 못하고 같은 행에 엑세스하기 위해 queue에 들어가기 때문임.

나는 표준 isolation 레벨의 차이가 그 구현을 위해 필요한 lock의 수에 따라 정의된다고 생각함.

만약 업데이트될 행들이 쓰기는 locked되지만 읽기는 가능하다면, 우리는 *Read Uncommited* 격리 수준을 얻으며, 이는 데이터가 커밋되기 전에 읽는 것을 허용함.

만약 업데이트될 행들이 읽기, 쓰기 전부 locked된다면, 우리는 *Read Commited* 격리 수준을 얻음: 커밋되지 않은 데이터를 읽는 것은 금지되지만, 쿼리를 여러번 날려도(한 트랜잭션에서) 동일한 결과를 얻지 못할 것임(non-repeatable read)

읽기와 업데이트 될 행들을 모든 작업에 대해 잠그면, 우리는 *Repeatable read* 격리 수준을 얻음 : 연속된 쿼리는 항상 같은 결과를 반환함.

그러나 *Serializable* 수준에는 문제가 있는데 : 아직 존재하지 않은 행을 잠글 수 없음.
이건 phantom read가 발생할 가능성을 남기는데 : 트랜잭션이 이전 쿼리의 조건에 맞는 행을 추가하면, 다음 쿼리에 그 행이 나타날 것임.

따라서, 일반적인 잠금은 완벽한 격리성을 제공하지 못함 : 이를 달성하려면, 행이 아닌 조건(predicate)에 lock을 걸어야 함.
이러한 *predicate* locks는 1976년에 R이 개발될 때 도입되었으나; 실제 적용 가능성은 간단한 조건에 한함: 두 다른 조건이 서로 충돌할 수 있는 가능성이 명확할 때만 가능해서임.
내가 알기로, predicate locks가 원래 의도된 대로 구현된 시스템은 없음.



[^1]::https://www.postgresql.org/docs/current/transaction-iso.html