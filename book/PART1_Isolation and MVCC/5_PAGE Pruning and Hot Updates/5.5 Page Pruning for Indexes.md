
페이지 가지치키는 단힐 힙 페이지에만 국한되며, 인덱스에 영향을 미치지 않는다고 정의했다.
그러나, 인덱스는 자체적인 pruning을 수행하며 [^1], 마찬가지로 단일페이지-이경우엔 인덱스 페이지에서 이루어진다.

인덱스 가지치기는 B-tree에 삽입이 일어날 때 원래 페이지에 공간이 없어서 페이지를 2개로 분할하려 할 때 발생한다.
문제는 일부 인덱스 항목이 나중에 삭제되더라도, 두 분리된 인덱스 페이지가 다시 합쳐지지 않는다는 것이다.
이는 인덱스를 부풀어 오르게(bloating)하며, 한번 부풀어진 인덱스는 많은 데이터가 삭제되도 축소되지 않는다.
그러나 가지치기로 일부 튜플을 제거할 수 있다면, 페이지 분할을 늦출 수 있다.

인덱스에서 가지치기 할 수 있는 튜플은 2가지 유형이 있다.

첫번째로, PostgreSQL은 죽은 것으로 표시된 튜플들을 가지치기한다. [^2]
앞서 말했듯이, PostgreSQL은 인덱스 스캔중에 어떤 인덱스에서도 보이지 않거나 존재하지 않는 튜플을 가리키는 인덱스 항목을 발견하면 해당 항목에 dead 태그를 설정한다.


죽은 튜플이 없으면, PostgreSQL은 하나의 테이블 행에 대한 여러 버전을 참조하는  인덱스 항목들을 확인한다.[^3]
MVCC 때문에, 업데이트 작업은 많은 행 버전을 생성하며, 그들 중 다수는 데이터베이스 경계 뒤로 사라질 것이다.
Hot update는 이러한 현상을 완화하지만, 항상 적용되는 것은 아니다 : 만약 업데이트하려는 열이 인덱스의 일부일 경우, 해당 참조는 모든 인덱스로 전파된다. 페이지를 분할하기 전에 아직 dead 태그가 붙지 않았지만 가지치기할 수 있는 행을 찾는 것이 합리적이다.
이를 위해 PostgreSQL은 힙 튜플의 가시성을 확인해야 한다. 이러한 확인 작업은 테이블에 접근해야 하므로, 기존 튜플을 복사하여 "유망한" 인덱스 튜플에 대해서만 수행된다. 페이지 분할을 허용하는 것보다 이러한 확인 작업을 수행하는 것이 더 저렴하기 때문이다.




[^1]:postgresql.org/docs/14/btree-implementation.html#BTREE-DELETION

[^2]:backend/access/nbtree/README, Simple deletion section

[^3]:backend/access/nbtree/README, Bottom-Up deletion section
include/access/tableam.h