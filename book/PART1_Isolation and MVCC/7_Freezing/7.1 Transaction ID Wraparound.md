
PostgreSQL에서, 트랜잭션ID는 32비트이다. 40억이라는 숫자는 꽤 큰 숫자이지만, 시스템이 활발하게 사용된 경우 매우 빠르게 소진된다.
예를 들어, 초당 평균 1,000번 트랜잭션이 발생할 경우(가상 트랜잭션 제외), 약 6주면 다 소진된다.

모든 트랜잭션 변화가 소진되면, 카운트를 리셋하여 다음 라운드를 시작해야 한다(이를 wraparound) 라고 부른다.
그러나 작은 트랜잭션 ID가 큰 트랜잭션 ID보다 오래된 것으로 간주할 수 있으려면, 할당된 번호가 항상 증가해야 한다. 따라서 카운터를 리셋한 후, 동일한 번호를 다시 사용하는 것은 불가능하다.

트랜잭션 ID에 64비트를 할당하면 이 문제를 완전히 해결할 수 있다. 그런데 왜 PostgreSQL은 안그랬을까? 왜냐면 모든 튜플 헤더는 두개의 트랜잭션ID (*xmin, xmax*)를 저장해야 하기 때문이다.
헤더는 이미 상당히 큰데 (데이터 정렬을 고려하면 24바이트), 더 많은 비트를 추가하면 8byte가 필요하게 된다.

> PostgreSQL은 일반적인 32비트 트랜잭션 IDS를 덧붙여 확장한 64비트 트랜잭션 ID를 구현하고 있지만, 이는 내부적으로만 사용되며 데이터 페이지에는 저장되지 않는다. [^1]

wraparound를 올바르게 처리하기 위해, PostgreSQL은 트랜잭션 ID가 아닌 트랜잭션의 나이를 비교해야 한다(해당 트랜잭션이 시작된 이후 발생한 트랜잭션의 수). 따라서, *greater*, *less* then 이라는 용어 대신 *older*(이전의), *younger*(이후의) 개념을 사용해야 한다.

코드에서, 이러한 비교는 단순히 32비트 산술 연산을 사용하여 구현된다 : 먼저 두 32비트 트랜잭션 ID 간의 차이를 비교하고, 그 결과를 0과 비교한다.

이를 시각화하려면, 시계의 숫자판으로 비교할 수 있다. 매 트랜잭션마다 시계 방향으로 반 바퀴는 미래, 반대 방향으로 반 바퀴는 과거를 나타낸다.

![](_static/CleanShot%20-000074.png)

그러나, 이 시각화에는 불편한 점이 있다. 오래된 트랜잭션 (T1)은 더 최근의 트랜잭션들과 비교할 때 멀리 과거에 위치하게 된다. 하지만 시간이 지나면 새로운 트랜잭션이 그것을 미래의 시점에서 보게 될 것이다. 만일 실제로 그런다면, 이는 파멸적이다 : 모든 새로운 트랜잭션들은 T1이 수행한 변경 내역을 보지 못할 것이기 때문이다.







[^1]:include/access/transam.h, FullTransactionId type

[^2]:backend/access/transam/transam.c, TransactionIdPrecedes function