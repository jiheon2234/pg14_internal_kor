
앞서 언급했듯이, 스냅샷의 하한선은 `xmin`으로 표현되며, 이는 스냅샷이 생성된 시점에 활성화된 가장 오래된 트랜잭션의 시작 ID를 나타낸다.
이 값은 매우 중요한데, 이는 스냅샷을 사용하는 트랜잭션의 경계를 정의하기 때문이다.

만약 트랜잭션이 활성화된 스냅샷이 없는 경우(ex : Read Committed 레벨에서 명령어 실행 간), 그 경계는 할당된 경우 자신의 ID로 정의된다.

경계를 넘어선 모든 트랜잭션들, 즉 (`xid < xmin`인 트랜잭션들)은 커밋된 것이 보장된다. 이는 트랜잭션이 경계를 넘어 현재의 행 버전을 볼 수 있다는 의미이다.

>짐작할 수 있듯, 이 용어는 물리학의 시간의 지평선(블랙홀) 개념에서 영감을 받았다.

PostgreSQL은 모든 프로세스의 현재 경계를 추적하며; 트랜잭션은 pg_stat_activity 테이블에서 자신의 경계를 볼 수 있다.

```sql
=> BEGIN;
=> SELECT backend_xmin FROM pg_stat_activity WHERE pid = pg_backend_pid();
backend_xmin
−−−−−−−−−−−−−−
793
(1 row)
```

가상 트랜잭션은 실제 ID를 가지지 않지만, 여전히 일반 트랜잭션과 마찬가지로 스냅샷을 사용하므로 그들만의 경계를 가진다.
유일한 예외는 활성화된 스냅샷이 없는 가상 스냅샷인데, 이 경우에는 경계는 의미가 없으며, 스냅샷과 가시성 측면에서 시스템에 대해 완전히 "투명"하다(다만 pg_stat_activity.backend_xmin이 오래된 스냅샷의 xmin을 포함하고 있을 순 있다.)

우리는 이와 비슷한 방식으로 데이터베이스 경계를 정의할 수 있다. 이를 위해서, 데이터베이스 내 모든 트랜잭션의 경계를 고려한 후, 가장 멀리있는 경계 즉 가장 오래된`xmin`을 가진 트랜잭션을 선택해야 한다. [^1]
경게를 넘어선 힙 튜플은 데이터베이스의 어떤 경계에서도 보이지 않게 되고, 이러한 튜플은 *vaccum*에 의해서 안전하게 정리될 수 있다-이것이 경계 개념이 실용적인 관점에서 중요한 이유이다.

![](_static/CleanShot%20-000067.png)

결론을 내리자면:
- 만일 Repeatable Read나 Serializable  트랜잭션(실제든 가상이든 상관없이) 이 오래 지속된다면, 해당 트랜잭션이 오래 유지되게 되며, VACUMMING이 지연된다.
<br>
- Read Committed 격리 수준에서의 실제 트랜잭션은 비록 어떠한 연산을 실행시키지 않고("idle in transaction" 상태)있더라도, 동일하게 데이터베이스 경계를 유지한다. 
<br>
- Read Committed 격리 수준에서의 가상 트랜잭션은 연산을 실행하는 도중에만 경계를 유지한다.

데이터베이스에는 단 하나의 경계만 존재하기 때문에, 만약 어떤 트랜잭션이 이 경계를 유지하고 있다면, 이 경계 내의 데이터를 그 트랜잭션이 접근하지 않아도 VACCUMING하지 못한다.

> 시스템 카탈로그의 Cluster-wide 테이블들은 모든 데이터베이스의 트랜잭션을 고려한 별되의 경계를 가지고 있다. 반대로, 임시 테이블은 현재 프로세스에서 실행 중인 트랜잭션 외에는 어떠한 트랜잭션도 신경쓰지 않는다.

이제 현재 실험으로 들어가 보자. 첫 세션에서 활성화된 트랜잭션은 여전히 데이터베이스 경계를 유지하고 있다; 트랜잭션 카운터를 증가시켜 확인할 수 있다.

```sql
		=> SELECT pg_current_xact_id();
		pg_current_xact_id
		−−−−−−−−−−−−−−−−−−−−
		794
		(1 row)

```

```sql
=> SELECT backend_xmin FROM pg_stat_activity WHERE pid = pg_backend_pid();
backend_xmin
−−−−−−−−−−−−−−
793
(1 row)
```

그리고 이 트랜잭션이 완료되어야만 경게가 앞으로 이동하고, 오래된 튜플들이 VACCUM에 의해 정리될 수 있다:

```sql
=> COMMIT;

=> SELECT backend_xmin FROM pg_stat_activity WHERE pid = pg_backend_pid();

backend_xmin
−−−−−−−−−−−−−−
795
```

이상적인 상황에서는, 자주 업데이트가 발생하는(새로운 행 버전들을 생성하는)경우에, 긴 트랜잭션과 결합하지 않는 것이 좋다. 테이블이나 인덱스가 부풀어오를 수 있기 때문이다.

[^1]:backend/storage/ipc/procarray.c, ComputeXidHorizons function