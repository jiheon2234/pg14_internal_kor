
불행히도, 이전 그림은 PostgreSQL이 실제로 하는 방식과는 관련이 없다. [^1]
문제는, 시스템은 트랜잭션이 언제 시작되었는지는 알고 있지만(트랜잭션 ID에 의해 정의) 트랜잭션이 완료된 시점은 어디에도 기록하지 않는다는 것이다.

> 커밋 시간을 추적하려면 [^2] `track_commit_timestamp` 파라미터를 활성화해야 하지만, 커밋 시간은 가시성 검사에 전여 관여하지 않는다(다만, replica 같은 외부 복제 솔루션 등의 목적으로는 유용하다).
> 
>  또한, PostgreSQL은 항상 커밋과 롤백 시간을 해당 WAL 로그에 기록하지만, 이 정보는 *시점복구(PITR)* 에만 사용된다.

우리가 알 수 있는 것은 트랜잭션의 현재 상태뿐이다. 이 정보는 서버의 공유 메모리에서 확인 가능하다:
`ProcArray` 데이터 구조는 모든 활성 세션과 해당 트랜잭션의 목록을 포함하고 있다.
트랜잭션이 완료되면, 해당 트랜잭션이 스냅샷 생성 시점에 활성화됬는지를 찾는 것은 불가능하다.

따라서, 스냅샷을 생성하려면 스냅샷이 생성된 시점을 기록하는 것 만으로는 충분하지 않다:
해당 시점에 모든 트랜잭션의 상태를 수집하는 것도 필요하다.
그렇지 않으면, 나중에 어떤 튜플이 스냅샷에서 보이거나 제외되어야 하는지를 알 수 없다.

스냅샷이 생성된 시점과 그 이후의 상황에서 시스템이 알 수 있는 정보를 살펴보자(흰색 원은 활성화된 트랜잭션을 나타내며, 검은색은 완료된 트랜잭션이다).

![](image/CleanShot%20-000065.png)

스탭샷이 생성된 시점에, 트랜잭션1이 실행 중이고 트랜잭션3이 아직 시작하지 않았다는 사실을 모른다면, 이러한 트랜잭션들은 두번째 트랜잭션과 (그 시점에 커밋된) 동일하게 보일 것이며, 이를 필터링 할 수 없을 것이다.

그래서, PostgreSQL은 임의의 과거 시점에서 일관덴 데이터 상태를 보여주는 스냅샷을 생성할 수 없다. 심지어 필요한 튜플들이 모두 힙 페이지에 존재하더라도 그렇다.
결과적으로, 과거 시점의 데이터를 조회하는 쿼리는 (temporal or flashback queries 라고 불리는) 구현이 불가능하다.

> 흥미롭게도, 그러한 기능들은 초기 PostgreSQL의 목표 중 하나였으며, 프로젝트 초기에는 구현됬지만, 프로젝트 지원이 커뮤니티로 넘어갔을때 제거되었다. [^3]

따라서, 스냅샷은 생성 시점에 저장된 여러 값들로 구성된다. [^4]

- `xmin` 은 스냅샷의 하한선이며, 이는 가장 오래된 활성 트랜잭션 ID(TXID)로 표현된다.
이보다 작은 ID를 가진 트랜잭션은 커밋되었거나(변경 사항이 스냅샷에 포함되었거나) 중단되었다(변경사항이 무시되었다).
<br>
- `xmax`는 스냅샷의 상한선이며, 가장 최근에 커밋되었던 트랜잭션의 값 + 1 이다. 이는 스냅샷이 생성된 시점을 정의한다. 이보다 큰 아이디를 가진 트랜잭션은 아직 실행 중이거나 존재하지 않는 트랜잭션이므로, 이들의 변경 사항은 보이지 않는다.
<br>
-  `xip_list`는 가상 트랜잭션을 제외하고 활성 트랜잭션들의 트랜잭션 ID 목록을 나타내며, 가상 트랜잭션은 가시성에 영향을 주지 않는다.

스냅샷은 몇몇 다른 파라미터도 포함하며, 지금은 설명하지 않을 것이다.
그래픽적으로, 스냅샷은 xmin에서 xmax까지의 트랜잭션을 포함하는 사각형으로 볼 수 있다.

![](image/CleanShot%20-000066.png)

가시성 규칙이 스냅샷에 의해 어떻게 정의되는지 이해하기 위해, 우리는 위의 시나리오를 accounts 테이블에서 정의할 것이다.


첫번째 트랜잭션은 첫 번째 행을 테이블에 삽입하고, 열려 있는 상태로 유지된다:

tx1
```sql
=> BEGIN;
=> INSERT INTO accounts VALUES (1, 'alice', 1000.00);
=> SELECT pg_current_xact_id();
pg_current_xact_id
−−−−−−−−−−−−−−−−−−−−
790
(1 row)
```

두 번째 트랜잭션은 두번째 행을 삽입하고, 즉시 커밋한다:

tx2
```sql
		=> BEGIN;
		=> INSERT INTO accounts VALUES (2, 'bob', 100.00);
		=> SELECT pg_current_xact_id();
		pg_current_xact_id
		−−−−−−−−−−−−−−−−−−−−
		791
		(1 row)
		=> COMMIT;
```

이 시점에서, 다른 세션에서 새로운 스냅샷을 생성하자. 우리는 특별한 함수를 사용하여 스냅샷을 즉시 확인할 것이다:

(새로운세션에서 스냅샷 생성)
```sql
				=> BEGIN ISOLATION LEVEL REPEATABLE READ;
				=> -- txid_current_snapshot() before v.13
				SELECT pg_current_snapshot();
				pg_current_snapshot
				−−−−−−−−−−−−−−−−−−−−−
				790:792:790
				(1 row)
```

이 함수는 콜론으로 구분된 스냅샷 구성 요소들을 나타낸다:
`xmin`,`xmax`,`xip-list`(활성 트랜잭션 목록; 이 경우 하나의 트랜잭션만 포함됨).

스냅샷을 생성한 후, 첫 트랜잭션을 커밋하자:

tx1
```sql
=> COMMIT;
```

세번째 트랜잭션은 스냅샷이 생성된 이후에 시작되며, 이 트랜잭션은 2번째 행을 수정하므로, 새로운 튜플이 나타난다:

tx3
```sql
			=> BEGIN;
			=> UPDATE accounts SET amount = amount + 100 WHERE id = 2;
			=> SELECT pg_current_xact_id();
			pg_current_xact_id
			−−−−−−−−−−−−−−−−−−−−
			792
			(1 row)
			=> COMMIT;
```

우리의 스냅샷은 오직 하나의 튜플만 볼 수 잇다:

(아까만든 새로운세션)
```sql
			=> SELECT ctid, * FROM accounts;
			ctid  | id | client | amount
			−−−−−−−−−−−−+−−−−+−−−−−−−−−−+−−−−−−−−
			(0,2) | 2  | bob   | 100.00
			(1 row)
```


그러나 테이블에는 튜플이 3개이다.

tx3
```sql
			=> SELECT * FROM heap_page('accounts',0);
			 ctid  | state  |  xmin   |  xmax
			−−−−−−−−+−−−−−−−−−+−−−−−−−−−+−−−−−−−−
			 (0,1) | normal |  790 c  |  0 a
			 (0,2) | normal |  791 c  | 792 c
			 (0,3) | normal |  792 c  |  0 a
			(3 rows)
```

그렇다면 PostgreSQL은 어떤 버전의 데이터를 보여줄지 어떻게 선택할까?
위의 규칙에 따라, 변경 사항은 커밋된 트랜잭션에 의해 이루어졌을때만 스냅샷에 포함되며, 그 트랜잭션은 다음 조건을 만족해야 한다.

- `xid < xmin` :  트랜잭션 아이디가 하한값보다 작을 경우, 이 변경 사항은 무조건 보여진다(ex : accounts 테이블을 생성한 트랜잭션처럼 오래된 트랜잭션임)
- `xmin <= xid <xmax : 트랜잭션 아이디가 사이에 있을 경우, 해당 트랜잭션은 `xip_list`에 포함되지 않았을 경우에만 보여진다.

첫 번째 행 (0,1)은 `xip_list`에 포함된 활성 트랜잭션에 의해 삽입되었기 때문에 보이지 않는다(스냅샷 범위에 포함되었을지라도)

두번째 행의 마지막 버전 (0,3)은 해당 트랜잭션ID가 스냅샷의 상한선을 넘어서기 때문에 보이지 않는다.

그러나, 두번째 행의 첫 버전 (0,2)는 보인다 : 행 삽입은 스냅샷 범위 내에 속하는 트랜잭션에 의해 수정되었으며, 이 트랜잭션은 `xip_list`에 포함되어있지 않기 때문에(삽입은 보인다).
반면에, 행 삭제는 스냅샷의 상한값을 초과하는 트랜잭션에 의해 수행되었기 때문에 보이지 않는다.

```sql
=> COMMIT;
```


[^1]: include/utils/snapshot.h 
backend/utils/time/snapmgr.c

[^2]:backend/access/transam/commit_ts.c

[^3]:https://arxiv.org/pdf/1901.01973

[^4]:backend/storage/ipc/procarray.c, GetSnapshotData function