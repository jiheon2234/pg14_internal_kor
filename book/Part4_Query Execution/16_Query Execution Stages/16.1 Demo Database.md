
이전 부분의 예제는 소수의 행만 가진 간단한 테이블을 기반으로 했다. 이후의 내용은 쿼리 실행을 다루는데, 이는 더 많은 요구를 필요로 한다 : 
우리는 연관된 테이블을 다뤄야 하며, 훨씬 더 많은 수의 행이 필요하다. 각 예제를 위해 새로운 데이터 세트를 만드는 대신, 러시아의 항공 승객 교통을 설명하는 기존의 데모 데이터베이스를 사용했다. [^1] 이는 몇가지 버전이 있으며, 우리는 2017-08-15에 생성된 더 큰 버전을 사용할 것이다. 이 버전을 설치하려면 데이터베이스 복사본이 포함된 파일을 아카이브에서 추출하고, `psql`에서 실행하자.

데모 데이터베이스를 개발할 때, 우리는 스키마가 추가 설명 없이도 이해할 수 있을 만큼 충분히 단순하게 만드려고 노력했다. 동시에, 의미 있는 쿼리를 작성할 수 있을 만큼 충분히 복잡하길 원했다.
이 데이터베이스는 실제와 유사한 데이터로 채워져 있어, 예제가 더 포괄적이고 작업하는데 흥미를 느낄 수 있다.

여기서는 주요 데이터베이스 객체만 간단히 다루겠다 ; 만약 전체 스키마를 검토하고 싶다면, 각주에 참조된 전체 설명을 살펴볼 수 있다.

메인 엔티티는 *예약*(*booking* 테이블)이다. 하나의 예약은 여러 승객을 포함할 수 있으며, 각 승객은 별도의 전자 티켓을 가진다.
승객은 별도의 엔티티로 구성되지 않으며, 모든 승객이 고유하다고 가정하겠다.

각 티켓은 하나 이상의 비행 구간을 포함한다.(*ticket_flights* 테이블에 매핑)
하나의 티켓이 여러 비행 구간을 가질 수 있는 경우는 두 가지인데 : 왕복 티켓이거나 연결 항공편을 위한 티켓일 때이다.
스키마에는 이를 위한 제약조건이 없지만, 하나의 예약 내 모든 티켓은 동일한 비행 구간을 가진다고 가정한다.

각 비행은(flights) 하나의 공항에서(airports) 다른 공항으로 이동한다. 동일한 비행편 번호를 가진 비행들은 동일한 출발지와 도착지를 가지지만, 출발 날짜는 다르다.

*routes* 뷰는 *flight*테이블 기반이며 특정 비행 날짜에 의존하지 않는 경로 정보를 표시한다.

체크인 시, 각 승객들은 좌석 번호가 포함된 항공권(*boarding_passes*)를 발급받는다. 승객은 해당 비행편이 티켓에 포함된 경우에만 체크인할 수 있다. 비행편-좌석 조합은 고유해야 하며 동일한 좌석에 두 탑승권을 발급하는 것은 불가능하다.

항공기에 좌석 수(seats)와 각 좌석의 여행 등급 간 분배는 해당 비행편을 수행하는 항공기 모델(aircraft)에 따라 달라진다. 각 항공기 모델은 단 하나의 객실 구성만 가질 수 있다고 가정한다.

일부 테이블은 대체 primary key를 사용하고, 다른 테이블은 자연 키(복합키)를 사용한다. 이는 오직 시연 목적을 위해서만 한 것이며, 좋은 사례는 아니다.

데모 데이터베이스는 실제 시스템의 덤프라고 생각할 수 있다 : 과거 특정 시점에 데이터를 스냅샷으로 뜬 것이다. 시간을 표시하려면 `booking.now()`함수를 호출할 수 있다. 실제 상황에서 `now()` 함수를 필요로 하는 데모 쿼리에서는 이 함수를 사용하자.

공항, 도시, 항공기 모델의 이름은 *airports_data*와 *aircrafts_data* 테이블에 있다 ; 이 정보는 러시아어와 영어로 제공된다.
이 챕터의 예제를 구성하기 위해 나는 주로 공항과 항공기의 뷰를 조회할 것이다. 이 뷰들은 ERD에서 그려지며, 출력 언어는 booking.lang 파라미터의 값에 따라 선택된다. 그러나 일부 기본 테이블의 이름이 쿼리 실행 계획에 여전히 나타날 수 있다.

![](image/Pasted%20image%2020241015170337.png)

[^1]:https://postgrespro.com/community/demodb
[^2]: 데이터는이거다운받기edu.postgrespro.com/demo-big-en-20170815.zip