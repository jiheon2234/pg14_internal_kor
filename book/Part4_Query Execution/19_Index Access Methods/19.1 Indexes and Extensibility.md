인덱스는 데이터 접근을 빠르게 하기 위한 목적으로 사용되는 데이터베이스 객체이다. 인덱스는 보조 도구로 : 모든 인덱스는 삭제될 수 있으며 힙 데이터에 기반해 다시 생성할 수 있다. 데이터 접근 속도를 높이는 것 외에도, 인덱스는 일부 무결성 제약 조건을 강제하는 데에도 사용된다.

PostgreSQL 코어에서는 6가지 내장된 인덱스 접근 방법을 제공한다 :

```sql
=> SELECT amname FROM pg_am WHERE amtype = 'i';

amname  
−−−−−−−−  
btree  
hash  
gist  
gin  
spgist  
brin  
(6 rows)

```

PostgreSQL의  확장성은 코어를 수정하지 않고도 새로운 접근 방식을 추가할 수 있음을 의미한다. 그러한 확장 중 하나가 (*bloom* 접근 방법) 표준 모듈 세트에 포함되어 있다.

다양한 인덱스 타입의 차이에도 불구하고, 모든 인덱스는 결국 키(인덱싱된 컬럼의 값)와 비교하여 그 키를 포함하는 튜플을 찾는다.
튜플은 6바이트 크기의 튜플ID(또는TID)로 참조된다. 키나 키에 대한 일부 정보를 알고 있으면, 테이블 전체를 스캔하지 않고도 필요한 데이터를 포함할 가능성이 있는 튜플을 빠르게 읽어낼 수 있다.

새로운 접근 방법을 확장으로 추가할 수 있도록 보장하기 위해, PostgreSQL은 공통 인덱싱 엔진을 구현한다. 이 엔진의 목적은 특정 접근 방법이 반환한 TID를 검색하고 처리하는 것이다 : 
- 해당 힙 튜플에서 데이터를 읽음
- 특정 스냅샷에 대해 튜플 가시성 확인
- 접근 방법의 평가가 불명확할 경우 조건을 다시 확인함

인덱싱 엔진은 최적화 단계에서 수행된 실행 계획의 수행에도 참여한다.
다양한 실행 경로를 평가할 때, optimizer는 모든 잠재적으로 적용 가능한 접근 방법의 속성을 알아야 한다 : 접근 방법이 필요한 순서대로 데이터를 반환할 수 있는지 또는 별도의 정렬 단계가 필요한지, 일부 첫 값을 즉시 반환할 수 있는지 또는 결과 집합을 모두 가져올 때까지 기다려야 하는지 등이다. 

접근 방식의 세부 사항을 알아야 하는 것은 옵티마이저 뿐만이 아니다. 인덱스를 생성할 때도 여러 질문에 답해야 한다 :  접근 방식이 다중 컬럼 인덱스를 지원하는가? 인덱스가 유일성을 보장하는가 ?

인덱싱 엔진은 다양한 접근 방법을 사용할 수 있도록 허용한다 ; 지원되기 위해서는, 접근 방식이 특정 인터페이스를 구현하여 그 기능과 속성을 선언해야 한다.

접근 방식은 다음과 같은 작업을 처리할 때 사용된다 : 
- 인덱스를 구축하는 알고리즘, 그리고 인덱스 항목을 삽입/삭제하는 알고리즘을 구현
- 인덱스 항목을 페이지 사이에 분배 (버퍼 캐시 매니저가 이후에 처리)
- vacuuming 알고리즘 구현
- 올바른 동시성을 위한 잠금 구현
- WAL 항목 생성
- 키를 사용하여 인덱싱된 데이터 검색
- 인덱스 스캔 비용 추정

확장성은 새로운 데이터 타입을 추가할 수 있는 능력으로도 나타난다. 접근 방식은 사전에 이러한 데이터 타입에 대해 알지 못한다. 따라서, 접근 방식은 이러한 임의의 데이터 타입을 연결할 수 있도록 자체 인터페이스를 정의해야 한다.

특정 접근 방식에서 새로운 데이터 타입을 사용하려면 해당하는 인터페이스를 구현해야 한다. 즉, 인덱스와 함께 사용할 수 있는 연산자와, 필요하다면 몇 가지 보조 지원 함수들을 제공해야 한다. 이러한 연산자와 함수들의 집합을 연산자 클래스라고 부른다.

인덱싱 로직은 접근 방법 자체에서 구현되지만, 일부는 연산자 클래스에 위임된다.
이 분배는 상당히 임의적이다 : B-tree는 모든 로직이 접근 방법에 내제되어 있지만, 다른 접근 방법들은 주된 프레임워크만 제공하고 모든 구현 세부사항들을 연산자 클래스에 맡기는 경우도 있다.
하나의 데이터 타입은 종종 여러 연산자 클래스로 지원되며, 사용자는 가장 적합한 동작을 제공하는 연산자 클래스를 선택할 수 있다.

 전체 그림의 작은 부분이다 :

![](image/Pasted%20image%2020241018161724.png)