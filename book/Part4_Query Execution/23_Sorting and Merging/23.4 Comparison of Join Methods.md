앞서 본 것처럼, 두 개의 데이터 집합은 3가지 다른 방법으로 조인될 수 있으며, 각각 장단점이 있다.

nested loop는 사전 조건이 필요 없으며, 결과 집합의 첫 번째 행을 즉시 반환할 수 있다.
이 조인 방식은 내부 집합을 완전히 스캔할 필요가 없는 유일한 방법이다(인덱스 접근이 가능한 경우).
이러한 특성 때문에, nested loop 알고리즘(인덱스와 결합해서)는 비교적 작은 행 집합을 처리하는 짧은 OLTP쿼리에 이상적인 선택이다.

nested loop의 약점은 데이터 양이 커질수록 명확해진다.
카타시안 곱을 수행할 경우, 이 알고리즘은 $O(n^2)$를 가지며, 비용은 조인데는 데이터 크기 곱에 비례하계 된다.
그러나, 실제로 카타시안 곱은 흔하지 않다; 외부 집합의 각 행에 대해, 실행기는 내부 집합의 인덱스를 사용해 특정 행들에 접근하게 되며, 이때 접근하는 행 수는 데이터 집합의 전체 크기에 의존하지 않는다(예를 들어, 예약당 평균 티켓 수는 예약 건수나 구매한 티켓 수가 증가해도 변하지 않음).
따라서, neseted loop의 복잡도는 종종 $O(n^2)$ 대신 선형적일때가 많다 (비록 높은 선형 계수일지라도).

nested loop 알고리즘의 중요한 특징은 범용성이다 : 이는 모든 조인 조건을 지원하는 반면, 다른 메서드들은 동등 조인만 가능하다. 이는 어떤 유형의(full join 제외)조건으로도 쿼리를 실행할 수 있지만, 비동등(non-equal)조인 을 큰 데이터 집합에 수행할 경우 예상보다 느리게 실행될 가능성이 높다는 것을 명심하자.

hash join은 큰 데이터 집합에 적절하다. RAM이 충분하다면, 두 데이터 집합에 대해 한 번의 순회만 필요하기 때문에 선형 복잡도를 가진다. 순차적 테이블 스캔과 결합되어, 이 알고리즘은 보통 많은 양의 데이터를 처리하는 OLAP 쿼리에 사용된다.

그러나, 만약 응답 시간이 처리량보다 더 중요하다면, 해시 조인은 최선의 선택이 아니다 : 해시 조인은 해시 테이블이 모두 구축될 때까지 결과 행을 반환하기 시작하지 않기 때문이다.

해시 조인 알고리즘은 equal join에만 사용 가능하다. 또다른 제한은 조인 키의 데이터 유형이 해시를 지원해야 된다는 것인데, 대부분의 유형이 지원한다.

nested loop 조인이 해시 조인보다 빠를 때가 있는데, *Memorize*노드를 사용해 내부 집합의 행들을 캐싱할 때이다(이또한 해시 테이블 사용).
해시 조인이 항상 내부 집합을 완전히 스캔해야 하는 반면, nested loop는 완전 스캔이 필요가 없기 때문에 비용을 줄일 수 있다.

merge join은 짧은 OLTP 쿼리와 긴 OLAP쿼리를 모두 처리할 수 있다. 이는 선형 복잡도를 가지며(조인할 집합을 한 번만 스캔하면 된다). 많은 메모리를 필요로 하지 않고, 별도의 전처리 없이 결과를 반환할 수 있다.
그러나, 데이터 집합이 이미 필요한 정렬 순서를 가지고 있어야 한다.
가장 효율적인 방법은 인덱스 스캔을 통해 데이터를 가져오는 것이다. 이는 행 수가 적을때 자연스로운 선택이다;
큰 데이터 집합에서, 힙 접근이 최소화되거나 전혀 일어나지 않는 경우 인덱스 스캔이 여전히 효율적일 수 있다.

적절한 인덱스가 없으면, 데이터 집합을 정렬해야 하지만, 이 연산은 메모리 집약적이고 $O(n\log_n)$의 복잡도를 가진다. 이 경우, 결과가 정렬될 필요가 없는 한, hash join이 merge join보다 항상 저렴하다.

merge join의 추가 장점은 내부 집합과 외부 집합이 대등하다는 점이다. 반면에, nested loop와 해시 조인의 효율성은 플래너가 적절한 내부와 외부 집합을 지정하는지의 여부에 크게 의존한다.

머지 조인은 equal join에만 사용 가능하다. 또한, 데이터 타입은 B-tree 연산자 클래스를 지원해야 한다.
아래 그래프는 다양한 조인 방법의 비용과  조인할 행 비율 간의 대략적인 의존 관계를 나타낸다.

![](image/Pasted%20image%2020241025145018.png)

선택도가 높다면, nested loop 조인은 두 테이블에 대해 인덱스 접근을 사용한다. 그런 다음 플래너는 외부 테이블의 전체 스캔으로 전환하게 되며, 이 전환은 그래프에서 선형 부분으로 나타난다.

여기서 해시 스캔은 두 테이블 모두를 완전 스캔한다. 그래프의 "계단"은 해시 테이블이 메모리를 다 채우고, 배치가 디스크로 쏟아지기 시작하는 순간이다.

인덱스 스캔이 사용되는 경우, 병합 조인은 작은 선형적 성장을 보인다.
만약 *work_mem*크기가 충분히 크다면, 해시 조인이 일반적으로 더 효과적이지만, 임시 파일 사용 측면에서는 병합 조인이 해시 조인보다 더 유리하다.

merge join의 상단 그래프는 인덱스가 없고 데이터를 정렬해야 할 때 비용이 증가한다. hash join의 경우처럼, 그래프의 "계단"은 메모리가 부족해 임시 파일을 사용하여 정렬할 때 나타난다.

이는 단지 하나의 예시일 뿐이며, 특정 상황에 따라 비용 비율은 다르게 나타날 수 있다.