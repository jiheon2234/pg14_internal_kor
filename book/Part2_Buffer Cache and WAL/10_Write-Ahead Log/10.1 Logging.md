
전력 장애, os 오류, 데이터베이스 서버 충돌 같은 장애가 발생할 경우, RAM의 모든 내용은 손상된다; 디스크에 기록된 데이터만 영구적으로 남는다.
장애 발생 후 서버를 다시 실행하려면 데이터 일관성을 복구해야 한다. 만약 디스크 자체가 손상되었다면, 백업 복구를 통해 동일한 문제를 해결해야 한다.

이론적으론, 디스크에서 항상 데이터 일관성을 유지할 수 있다. 하지만 실제로는, 서버가 항상 랜덤한 페이지를 디스크에 기록해야 한다는 것을 의미하며(비록 순차적인 쓰기가 더 저렴하지만), 이러한 쓰기의 순서는 특정 순간에도 일관성이 손상되지 않도록 보장해야 한다(이는 복잡한 인덱스 구조를 다룰 때 매우 어려운 일이다).

대다수의 데이터베이스 시스템과 마찬가지로, PostgreSQL은 다른 접근 방식을 사용한다.

서버가 실행중일 땐, 일부 데이터는 메모리에서만 존재하며, 영구 저장소로의 기록이 지연된다.
따라서 서버가 실행되는 동안 디스크에 저장된 데이터는 항상 일관성이 없는 상태다. 이는 페이지들이 한꺼번에 플러시되지 않기 때문이다.
하지만 메모리에서 일어나는 각 변경 사항은(ex:버퍼 캐시에서 수행된 페이지 업데이트)는 로그에 기록된다 : PostgreSQL은 이 작업을 다시 수행할 필요가 있을 때에 대비해, 해당 작업을 반복하는데 필요한 모든 중요한 정보를 포함하는 로그 항목을 생성한다. [^1]

페이지 수정과 관련된 로그 항목은 수정된 페이지 자체가 디스크에 기록되기 전에 디스크에 기록되어야 한다. 그래서 이 로그의 이름이 **write-ahed-log**(*WAL*)이다.
이 요구 사항은 PostgreSQL에서 장애가 발생했을때 디스크에서 WAL 항목을 읽고 이를 재실행하여, 이미 완료된 작업이지만 결과가 메모리에만 남아 있고 디스크에 기록되어 있지 않는 작업들을 반복할 수 있도록 도와준다.

write-ahead log를 유지하는 것은 랜덤한 페이지를 디스크에 기록하는 것보다 더 효율적이다. WAL 항목은 여녹적인 데이터 스트림을 이루기 때문에, HDD에서도 처리할 수 있으며, 또한, WAL 항목은 종종 페이지 크기보다 작다.

장애가 발생한 경우 데이터 일관성을 깨뜨릴 가능성이 있는 모든 작업을 로그로 기록해야 한다.
특히, 다음과 같은 작업들이 WAL에 기록된다 : 

- 버퍼 캐시에서 수행된 페이지 수정-쓰기 작업이 지연되기 때문에 
<br>
- 트랜잭션 커밋/롤백-상태 변경이 *CLOG* 버퍼에서 발생하며, 즉시 디스크에 기록되지 않기 때문에
<br>
- 파일 작업(테이블이 추가되거나 삭제될 때 파일 및 디렉토리의 생성/삭제)-이러한 작업은 데이터 변경과 동기화되어야 하기 때문에

다음 작업들은 로깅되지 않는다:

- *UNLOGGED*테이블에 대한 작업
  <br>
- 임시 테이블에 대한 작업-이 테이블들의 생명 주기는 해당 세션이기 때문에
  <br>

> PostgreSQL 10  이전엔, 해시 인덱스도 로그에 기록되지 않았다. 해시 인덱스의 유일한 목적은 해시 함수를 다양한 데이터 유형과 매핑하는 것이였다.

충돌 복구 외에도, *WAL*은 백업 또는 replica에서 특정 시점 복구 (POINT_IN_TIME RECOVERY)에 사용될 수 있다.





[^1]:postgresql.org/docs/14/wal-intro.html

