
비-휘발성 저장소에 도달하기 전에(하드디스크 등) 데이터는 여러 캐시를 거칠 수 있다.

디스크 쓰기는 단순히 OS에 데이터를 그 캐시에 저장하라고 지시하는 것에 불과하다(RAM처럼 캐시도 장애에 취약하다). 실제 쓰기는 OS의 I/O 스케줄러의 설정에 따라 비동기적으로 수행된다.

스케줄러가 누적된 데이터를 플러시하도록 결정하면, 이 데이터는 스토리지 장치(하드디스크등)의 캐시로 이동한다. 스토리지 장치 또한 쓰기를 지연시키는데, 예를 들어 인접한 페이지들을 묶어 기록하는 식이다. 또한 RAID 컨트롤러는 디스크와 OS 사이에 또 하나의 캐시 계층을 추가한다.

특별한 조치를 취하지 않는 한, 데이터가 디스크에 안전하게 저장된 시점은 알 수 없다. 보통은 WAL이 있기 때문에 크게 중요하지 않지만, WAL 항목 자체는 디스크에 즉시 안전하게 저장되어야 한다. [^1]
이것은 비동기 모드에서도 마찬가지인데-그렇지 않으면 WAL 항목이 수정된 데이터보다 먼저 디스크에 기록되었다는 것을 보장할 수 없다.

*checkpointer* 프로세스는 dirty 페이지가 OS 캐시에서 디스크로 기록되도록 하여 데이터를 신뢰할 수 있게 저장해야 한다. 또한, 다른 프로세스가 수행한 모든 파일 작업(페이지 쓰기, 파일 삭제 등)을 동기화해야한다 : 체크포인트가 완료될 때, 이러한 작업의 결과는 모두 디스크에 기록되어 있어야 한다.[^2]

fail-safe한 쓰기가 요구되는 다른 상황들도 있는데, 예를 들어 최소한의 WAL 레벨에서 로그되지 않는  작업을 수행할 때이다.

OS는 데이터를 비휘발성 저장소에 즉시 기록하는 것을 보장하는 다양한 방법을 제공한다. 이러한 방법은 크게 두 가지로 나뉠수 있다 :
- 쓰기 후 별도의 동기화 명령을 호출하는 방법 (fsync, fdatasync) 등
- 파일을 열거나 기록할 때 동기화 수행 요구 사항(또는 버퍼 캐시를 우회하는 직접 쓰기)

*pg_test_fsnyc* 유틸리티는 OS와 파일시스템에 따라 WAL을 동기화하는 가장 적합한 방법을 결정하는데 도움을 준다; 선호되는 방법은 *wal_sync_method* 파라미터에 지정할 수 있다.
다른 작업에 대해서는, 동기화 방법은 자동적으로 선택되고 설정할 수 없다. [^3]

여기서 미묘한 부분은, 특정한 케이스에서 가장 적합한 방법이 하드웨어에 따라 결정된다는 것이다.
예를 들어, 백업 배터리가 있는 컨트롤러를 사용한다면, 캐시의 이점을 누릴 수 있는데, 배터리가 정전 시에도 데이터를 보호해 주기 때문이다.

비동기 커밋과 동기화의 부재는 완전히 다른 개념이라는 것을 명시하자. 동기화를 비활성화하면(*fsync* 파라미터를 이용해서) 시스템 성능을 향상시키지만, 장애가 발생되면 치명적인 데이터 손실이 발생할 수 있다.
비동기 모드는 일반적인 상태로 장애 복구를 보장하지만, 가장 최근의 데이터 업데이트 일부는 누락될 수 있다.





[^1]:[backend/access/transam/xlog.c, issue_xlog_fsync function](https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=src/backend/access/transam/xlog.c;hb=REL_14_STABLE)

[^2]:[backend/storage/sync/sync.c](https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=src/backend/storage/sync/sync.c;hb=REL_14_STABLE)

[^3]:[backend/storage/file/fd.c, pg_fsync function](https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=src/backend/storage/file/fd.c;hb=REL_14_STABLE)