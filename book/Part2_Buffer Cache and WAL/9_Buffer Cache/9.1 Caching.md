
현대 컴퓨터 시스템에서, 캐싱은 하드웨어와 소프트웨어 레벨 둘다 사용된다. 프로세서만 하더라도 3~4단계의 캐시를 가질 수 있다. RAID 컨트롤러와 디스크도 자체 캐시를 추가한다.

캐싱은 빠른 메모리와 느린 메모리의 성능 차이를 완화하는데 사용된다. 빠른 메모리는 비싸고 용량이 작지만,  느린 메모리는 더 크고 저렴하다.그러므로, 빠른 메모리는 느린 메모리에 저장된 모든 데이터를 수용할 수 없다.
그러나 대부분의 경우, 특정 순간에 사용되는 데이터는 일부분에 불과하기 때문에, hot한 데이터를 위해 일부 빠른 메모리를 캐시로 할당하여 느린 메모리 접근으로 인한 오버헤드를 현저히 줄일 수 있다.

PostgreSQL에서, buffer cache [^1]는 디스크 접근(ms), RAM 접근(ns)의 균형을 맞추기 위해   relation pages를 보유한다.

운영 체제는 동일한 목적을 수행하는 자체 캐시를 가지고 있다. 이 이유로, 데이터베이스 시스템은 보통 이중 캐싱을 피하도록 설계된다 : 디스크에 저장된 데이터는 일반적으로 운영 체제의 캐시를 우회하여 직접 쿼리된다. 그러나 PostgreSQL은 다른 접근 방식을 사용하는데 : 모든 데이터를 버퍼링된 파일 작업을 통해 읽고 쓰는 것이다.

>  직접 I/O를 적용하면 이중 캐싱을 피할 수 있다. 이렇게 하면 PostgreSQL이 버퍼링된 페이지를 운영체제에 복사하는 대신 직접 메모리에 접근하여 (DMA) 오버헤드를 줄일 수 있다; 또한, 디스크에 대한 물리적 쓰기를 직접 제어할 수 있다.
>  그러나,  직접 I/O는 버퍼링으로 활성화된 데이터 prefetching을 지원하지 않으므로, 이는 비동기 I/O를 통해 별도로 구현해야 한다. 이는 postgreSQL 코어에서 코드를 많이 수정해야 하고, 직접 비동기 I/O 자원과 관련된 운영 체제 호환성 문제도 처리해야 한다. 
>  하지만 비동기 통신이 설정되면 기다리지-않는 디스크 접근이라는 추가적인 이점을 누릴 수 있다.

Postgres 커뮤니티는 이미 이 중요한 작업을 시작했지만[^2] 반영되기는 오래 걸릴 것이다.

[^1]:backend/storage/buffer/README
[^2]:www.postgresql.org/message-id/flat/20210223100344.llw5an2aklengrmn%40alap3.anarazel.de

