Postgresql 서버는 여러 상호작용하는 프로세스로 구성됨.

서버가 시작할때, 처음 실행되는 프로세스는 `POSTGRES` 이며,  전통적으로 *postmaster*라고 불림.
이 프로세스는 다른 모든 프로세스를 생성하고(유닉스 게열 시스템에선 fork 시스템콜을 사용) 이들을 관리함; 만일 어떤 프로세스가 실패하면, *postmaster*가 이를 재시작함( 공유 데이터가 손상될 위험이 있는 경우 전체 서버를 재시작함).

	그 단순성 때문에, 이 프로세스 모델은 postgresql에서 초창기부터 사용되었으며, 이후로도 스레드 모델로 전환할 것인지에 대해 계속 논의하고 있음. (아직까지 프로세스 모델임)
	
	현재의 모델에는 몇가지 약점이 있음; 정적 공유 메모리 할당은 버퍼 캐시와 같은 구조를 동적으로 할당할 수 없고 ; 병렬 알고리즘은 구현이 어렵고 예상보다 효율적이지 않음; 세션은 프로세스에 강하게 결합되어 있음;
	스레드를 사용하는 것이 유망해 보이지만, 이는 격리, OS 호환성, 자원 관리 등과 관련된 몇 도전과제를 수반함.
	그러나 이를 구현하기 위해선 근본적인 코드 개편과 수년간의 작업이 필요하므로, 현재로선 보수적인 관점이 우세함; 가까운 미래에도 그럴거임.

Postgresql 서버는 백그라운드 프로세서에 의해 유지됨. 여기 중요한 것들이 있음;

- **startup** :  장애 발생 후 시스템을 복원함
- **autovacuum** : 테이블, 인덱스에서 오래된 데이터 제거
- **wal writer** :  wal[^1]를 디스크에 기록
- **checkpointer** :  체크포인트를  사용 (데이터무결성 관련)
- **writer**  dirty page를 디스크로 플러시
- **status collector** 인스턴스의 사용 통계 수집
- **wal sender**  wal 을 복제서버로 전송
- **wal receiver**  wal 을 복제서버에서 수신

이들 프로세스 중 일부는 작업이 완료되면 종료되고, 다른 일부는 항상 돌고 있으며 일부는 비활성화 가능.

> 각 프로세스는 설정 파라미터에 의해 관리되며, 가끔 수십개의 파라미터가 관련될 수도 있음.
> 서버를 포괄적 방식으로 설정하려면,  그 내부 작동 방식을 잘 이해해야 함.
> 그러나 일반적인 고려 사항은 어느정도 적절한 초기값을 설정할 수 있을 뿐; 나중에 모니터링 데이터를 기반으로 세밀하게 튜닝해야 됨.

프로세스 간 상호작용을 활성화하려고 postmaster는 모든 프로세스에서 접근 가능한 *공유 메모리*를 할당함.

디스크(특히 HDD, SSD도 마찬가지)는 RAM보다 훨씬 느리기 때문에, Postgresql은 캐싱을 사용함 : 공유 메모리의 일부는 최근에 읽은 페이지를 위해 예약되었으며, 이를 통해 한번 이상 페이지가 필요할 때 반복적인 디스크 접근의 오버헤드를 줄임.
수정된 데이터는 즉시 디스크에 플러시되지 않고, 일정한 지연 후에 플러시됨.

버퍼 캐시는 공유 메모리의 대부분을 차지하며, 디스크 접근 속도를 늘리기 위한 다른 버퍼들을 사용함.

운영 체제도 자체적인 캐시를 가지고 있으므로, Postgresql(거의)은 운영 체제의 메커니즘을 우회하여 직접 I/O하지 않음으로, 이는 이중 캐싱을 초래함.

![](_static/Pasted%20image%2020240919140127.png)


장애가 발생할 경우( 정전이나 운영체제의 충돌 ), 버퍼캐시를 포함해 메머리에 저장된 정보는 사라짐.
디스크에 남아 있는 파일들은 서로 다른 시점의 페이지를 가지고 있을 수 있음.
데이터를 일관성있게 복구하기 위해서, Postgresql은 운영 중 *Write-ahead-log* (wal) 을 유지하며, 이를 통하여 필요할 때 손실된 작업을 복구 가능함.


[^1]: Write-ahead-log

