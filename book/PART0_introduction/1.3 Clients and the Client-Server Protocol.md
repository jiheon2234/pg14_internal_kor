*postmaster* 프로세스의 다른 작업은, 들어오는 커넥션을 대기하는 것임.
새로운 클라이언트가 나타나면, postmaster는 별도의 백엔드 커넥션을 생성함.
클라이언트는 이 백엔드와 연결을 설정하고, 세션을 시작함.
이 세션은 연결이 끊기거나 종료할때까지 계속됨.

서버는 각 클라이언트마다 새로운 백엔드 프로세스를 생성해야 함.
만일 많은 클라이언트가 연결을 시도한다면, 문제가 될 수 있음.

> 각 프로세스는 catalog table, prepared statements, intermediate query result 및 다른 데이터를 캐시하기 위해 메모리가 필요함.
> 커넥션 많아질수록, 더 많은 메모리가 필요함


> 연결이 짧고 빈번하다면 ( 클라이언트가 쿼리하나하고 종료할경우)
> 연결을 설정하고, 새로운 프로세스를 생성하고, 필요없는 로컬 캐싱하는 비용이 엄청나게 높음.

> 더 많은 프로세스가 시작될수록, 프로세스 목록을 스캔하는데 더 많은 시도가 필요하고 더 자주 수행됨. 결과적으로, 클라이언트 수가 증가할수록 성능이 저하됨.


이 문제는 생성된 백엔드 프로세스의 수를 제한하는 *connection polling*으로 해결할 수 있음. 
Postgresql은 이러한 기능을 내장하지 않으므로, 서드파티 솔루션을 사용해야 함:  애플리케이션 서버에 통합된 pooling manager나 외부 도구 (ex PgBouncer, Odyssey).
이 접근은 보통 각 서버 백엔드가 서로 다른 클라이언트의 트랜잭션을  순차적으로 실행함을 의미.
이는 애플리케이션 개발에 몇몇 제약을 가하게 되는데, 트랜잭션에 로컬인 자원만 사용할 수 있고, 전체 세션에 대한 자원은 사용할 수 없음. 

클라이언트와 서버가 서로 이해하려면, 동일한 인터페이스 프로토콜을 사용해야만 함. 이건 보통 표준 libpq 라이브러리를 기반으로 하지만, 커스텀 구현도 존재함.

가장 일반적인 용어로 말하자면, 이 프로토클은 클라이언트가 서버에 연결하고  SQL쿼리를 실행할 수 있게 함.

커넥션은 항상 특정 데이터베이스에 대해 특정 역활 또는 사용자를 대신하여 사용됨.
서버가 데이터베이스 클러스터를 지원하지만, 어플리케이션에서 각 데이터베이스를 연결하려면 별도의 커넥션을 사용해야 됨.
이 시점에서 인증이 수행됨 : 백엔드 프로세스는 사용자의 신원을 확인하고 ( 예를들어, 비밀번호를 물어봄) 이 유저가 서버 및 지정된 데이터베이스에 연결할 권한이 있는지 체크함.

SQL 쿼리는 텍스트 문자열로 백엔드 프로세스에 전달되며, 프로세스가 파싱하고, 쿼리를 최적화하며, 실행 후 결과를 클라이언트에 반환함.